Excellente question 👌 — tu veux donc :

> créer une Map (par exemple issue d’un traitement parallèle ou d’un chargement),
l’ajouter dynamiquement dans le contexte Spring,
puis pouvoir l’injecter avec @Autowired dans d’autres beans.



C’est faisable de plusieurs manières selon le moment où ta Map est créée (au démarrage ou à l’exécution).
Je te montre les 3 méthodes robustes 👇


---

🧩 1. Déclaration via un @Bean (au démarrage)

Si tu peux créer la Map dès l’initialisation du contexte :

@Configuration
public class MapConfig {

    @Bean(name = "myObjectMap")
    public Map<String, MyObject> myObjectMap() {
        Map<String, MyObject> map = new HashMap<>();
        map.put("A", new MyObject("A"));
        map.put("B", new MyObject("B"));
        return map;
    }
}

Et ensuite tu l’injectes où tu veux :

@Component
public class MyService {

    @Autowired
    @Qualifier("myObjectMap")
    private Map<String, MyObject> myObjectMap;

    public void printAll() {
        myObjectMap.forEach((k,v) -> System.out.println(k + " -> " + v));
    }
}

✅ Simple
✅ Type-safe
❌ La map est figée après le démarrage


---

🧩 2. Injection dynamique à l’exécution (registre manuel)

Si tu veux ajouter dynamiquement une Map dans le contexte après coup (par exemple calculée par un job parallèle Spark ou autre) :

@Autowired
private ConfigurableApplicationContext context;

public void registerMap(String beanName, Map<?, ?> map) {
    context.getBeanFactory().registerSingleton(beanName, map);
}

Tu peux ensuite faire :

Map<String, MyObject> resultMap = computeInParallel();
registerMap("myObjectMap", resultMap);

Et ensuite, n’importe quel bean peut faire :

@Autowired
@Qualifier("myObjectMap")
private Map<String, MyObject> myObjectMap;

✅ Permet d’ajouter après démarrage
✅ Accessible partout via injection
⚠️ Il faut que le registerSingleton soit appelé avant que d’autres beans en aient besoin


---

🧩 3. Création via un @Component dédié

Tu peux aussi encapsuler la Map dans un bean singleton custom :

@Component
public class ObjectMapHolder {
    private Map<String, MyObject> map = new HashMap<>();

    public void setMap(Map<String, MyObject> newMap) {
        this.map = newMap;
    }

    public Map<String, MyObject> getMap() {
        return map;
    }
}

Puis :

@Autowired
private ObjectMapHolder holder;

public void load() {
    Map<String, MyObject> computed = computeInParallel();
    holder.setMap(computed);
}

Et tu peux injecter ObjectMapHolder n’importe où.

✅ Facile à mettre à jour à chaud
✅ Garde le typage
❌ Pas directement une Map, mais un wrapper


---

🧠 Résumé

Besoin	Solution	Injection

Map statique connue au démarrage	@Bean dans @Configuration	@Autowired @Qualifier
Map calculée dynamiquement	registerSingleton()	@Autowired @Qualifier
Map modifiable à chaud	ObjectMapHolder singleton	@Autowired



---

Souhaites-tu que je te montre un exemple complet avec une List<MyObject> calculée en parallèle → convertie en Map → injectée automatiquement dans un bean Spring ?

