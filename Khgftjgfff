Excellente question ğŸ‘Œ â€” tu veux donc :

> crÃ©er une Map (par exemple issue dâ€™un traitement parallÃ¨le ou dâ€™un chargement),
lâ€™ajouter dynamiquement dans le contexte Spring,
puis pouvoir lâ€™injecter avec @Autowired dans dâ€™autres beans.



Câ€™est faisable de plusieurs maniÃ¨res selon le moment oÃ¹ ta Map est crÃ©Ã©e (au dÃ©marrage ou Ã  lâ€™exÃ©cution).
Je te montre les 3 mÃ©thodes robustes ğŸ‘‡


---

ğŸ§© 1. DÃ©claration via un @Bean (au dÃ©marrage)

Si tu peux crÃ©er la Map dÃ¨s lâ€™initialisation du contexte :

@Configuration
public class MapConfig {

    @Bean(name = "myObjectMap")
    public Map<String, MyObject> myObjectMap() {
        Map<String, MyObject> map = new HashMap<>();
        map.put("A", new MyObject("A"));
        map.put("B", new MyObject("B"));
        return map;
    }
}

Et ensuite tu lâ€™injectes oÃ¹ tu veux :

@Component
public class MyService {

    @Autowired
    @Qualifier("myObjectMap")
    private Map<String, MyObject> myObjectMap;

    public void printAll() {
        myObjectMap.forEach((k,v) -> System.out.println(k + " -> " + v));
    }
}

âœ… Simple
âœ… Type-safe
âŒ La map est figÃ©e aprÃ¨s le dÃ©marrage


---

ğŸ§© 2. Injection dynamique Ã  lâ€™exÃ©cution (registre manuel)

Si tu veux ajouter dynamiquement une Map dans le contexte aprÃ¨s coup (par exemple calculÃ©e par un job parallÃ¨le Spark ou autre) :

@Autowired
private ConfigurableApplicationContext context;

public void registerMap(String beanName, Map<?, ?> map) {
    context.getBeanFactory().registerSingleton(beanName, map);
}

Tu peux ensuite faire :

Map<String, MyObject> resultMap = computeInParallel();
registerMap("myObjectMap", resultMap);

Et ensuite, nâ€™importe quel bean peut faire :

@Autowired
@Qualifier("myObjectMap")
private Map<String, MyObject> myObjectMap;

âœ… Permet dâ€™ajouter aprÃ¨s dÃ©marrage
âœ… Accessible partout via injection
âš ï¸ Il faut que le registerSingleton soit appelÃ© avant que dâ€™autres beans en aient besoin


---

ğŸ§© 3. CrÃ©ation via un @Component dÃ©diÃ©

Tu peux aussi encapsuler la Map dans un bean singleton custom :

@Component
public class ObjectMapHolder {
    private Map<String, MyObject> map = new HashMap<>();

    public void setMap(Map<String, MyObject> newMap) {
        this.map = newMap;
    }

    public Map<String, MyObject> getMap() {
        return map;
    }
}

Puis :

@Autowired
private ObjectMapHolder holder;

public void load() {
    Map<String, MyObject> computed = computeInParallel();
    holder.setMap(computed);
}

Et tu peux injecter ObjectMapHolder nâ€™importe oÃ¹.

âœ… Facile Ã  mettre Ã  jour Ã  chaud
âœ… Garde le typage
âŒ Pas directement une Map, mais un wrapper


---

ğŸ§  RÃ©sumÃ©

Besoin	Solution	Injection

Map statique connue au dÃ©marrage	@Bean dans @Configuration	@Autowired @Qualifier
Map calculÃ©e dynamiquement	registerSingleton()	@Autowired @Qualifier
Map modifiable Ã  chaud	ObjectMapHolder singleton	@Autowired



---

Souhaites-tu que je te montre un exemple complet avec une List<MyObject> calculÃ©e en parallÃ¨le â†’ convertie en Map â†’ injectÃ©e automatiquement dans un bean Spring ?

