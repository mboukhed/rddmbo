Parfait — voici un pack Spring Core (pas Boot) minimal et propre pour gérer :

la création de TokenCredential (Workload Identity / Managed Identity / SPN),

la récupération de jetons par scope (ARM, Storage, Key Vault, …),

la lecture de secrets Key Vault,

avec config par propriétés (sans casser tes signatures existantes).



---

1) Interfaces

// AzureTokenService.java
import com.azure.core.credential.AccessToken;

public interface AzureTokenService {
    /** Ex: "https://vault.azure.net/.default" */
    AccessToken getAccessToken(String scope);
    default String getBearer(String scope) { return getAccessToken(scope).getToken(); }
}

// VaultSecretService.java
public interface VaultSecretService {
    String getSecret(String name); // retourne la valeur brute du secret
}


---

2) Propriétés (Spring Core)

// AzureAuthProperties.java
public class AzureAuthProperties {
    /** URL du Key Vault ex: https://my-vault.vault.azure.net */
    private String vaultUrl;

    /** Mode préféré: workload|managed|spn|auto (défaut: auto) */
    private String mode = "auto";

    /** Pour SPN direct ou SPN stocké dans KV */
    private String tenantId;   // optionnel si via KV
    private String clientId;   // optionnel si via KV
    private String clientSecret; // optionnel si via KV

    /** Noms de secrets KV si tu stockes le SPN dans le Vault */
    private String kvSpnTenantSecretName;
    private String kvSpnClientIdSecretName;
    private String kvSpnClientSecretName;

    // getters/setters ...
}


---

3) Fabrique de credentials (choix auto WI/MI/SPN)

// AzureCredentialFactory.java
import com.azure.core.credential.TokenCredential;
import com.azure.identity.*;

import java.util.Objects;

public class AzureCredentialFactory {

    public static TokenCredential build(AzureAuthProperties p) {
        String mode = p.getMode() == null ? "auto" : p.getMode().toLowerCase();

        switch (mode) {
            case "workload":
                return new WorkloadIdentityCredentialBuilder().build();

            case "managed":
                return new ManagedIdentityCredentialBuilder().build();

            case "spn":
                ensure(Objects.nonNull(p.getTenantId()), "tenantId manquant");
                ensure(Objects.nonNull(p.getClientId()), "clientId manquant");
                ensure(Objects.nonNull(p.getClientSecret()), "clientSecret manquant");
                return new ClientSecretCredentialBuilder()
                        .tenantId(p.getTenantId())
                        .clientId(p.getClientId())
                        .clientSecret(p.getClientSecret())
                        .build();

            default: // "auto" — laisse Azure SDK choisir (WI/MI d'abord)
                return new DefaultAzureCredentialBuilder()
                        .excludeEnvironmentCredential(false) // lit AZURE_* si présents
                        .build();
        }
    }

    private static void ensure(boolean cond, String msg) {
        if (!cond) throw new IllegalStateException(msg);
    }
}


---

4) Implémentations des services

// AzureTokenServiceImpl.java
import com.azure.core.credential.AccessToken;
import com.azure.core.credential.TokenCredential;
import com.azure.core.credential.TokenRequestContext;

public class AzureTokenServiceImpl implements AzureTokenService {
    private final TokenCredential credential;

    public AzureTokenServiceImpl(TokenCredential credential) {
        this.credential = credential;
    }

    @Override
    public AccessToken getAccessToken(String scope) {
        return credential.getToken(new TokenRequestContext().addScopes(scope)).block();
    }
}

// VaultSecretServiceImpl.java
import com.azure.core.credential.TokenCredential;
import com.azure.security.keyvault.secrets.SecretClient;
import com.azure.security.keyvault.secrets.SecretClientBuilder;

public class VaultSecretServiceImpl implements VaultSecretService {
    private final SecretClient client;

    public VaultSecretServiceImpl(String vaultUrl, TokenCredential credential) {
        this.client = new SecretClientBuilder()
                .vaultUrl(vaultUrl)
                .credential(credential)
                .buildClient();
    }

    @Override
    public String getSecret(String name) {
        return client.getSecret(name).getValue();
    }
}


---

5) Config Spring Core (Java Config)

// AzureAuthConfig.java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.azure.core.credential.TokenCredential;

@Configuration
public class AzureAuthConfig {

    @Bean
    public AzureAuthProperties azureAuthProperties() {
        AzureAuthProperties p = new AzureAuthProperties();
        // Charge depuis system properties/env (exemples) — adapte si tu as un PropertySourcesPlaceholderConfigurer
        p.setVaultUrl(System.getProperty("azure.vault.url", System.getenv("AZURE_VAULT_URL")));
        p.setMode(System.getProperty("azure.auth.mode", System.getenv().getOrDefault("AZURE_AUTH_MODE", "auto")));

        // SPN direct (facultatif si tu préfères KV)
        p.setTenantId(System.getProperty("azure.tenant", System.getenv("AZURE_TENANT_ID")));
        p.setClientId(System.getProperty("azure.client", System.getenv("AZURE_CLIENT_ID")));
        p.setClientSecret(System.getProperty("azure.client.secret", System.getenv("AZURE_CLIENT_SECRET")));

        // Secrets KV (si tu stockes le SPN dedans)
        p.setKvSpnTenantSecretName(System.getProperty("kv.spn.tenant", "spn-tenant-id"));
        p.setKvSpnClientIdSecretName(System.getProperty("kv.spn.client", "spn-client-id"));
        p.setKvSpnClientSecretName(System.getProperty("kv.spn.secret", "spn-client-secret"));
        return p;
    }

    @Bean
    public TokenCredential primaryCredential(AzureAuthProperties p) {
        return AzureCredentialFactory.build(p);
    }

    @Bean
    public AzureTokenService azureTokenService(TokenCredential cred) {
        return new AzureTokenServiceImpl(cred);
    }

    @Bean
    public VaultSecretService vaultSecretService(AzureAuthProperties p, TokenCredential cred) {
        if (p.getVaultUrl() == null) {
            throw new IllegalStateException("azure.vault.url manquant");
        }
        return new VaultSecretServiceImpl(p.getVaultUrl(), cred);
    }

    /**
     * Optionnel : fournisseur d'une cred SPN construite à partir de secrets KV
     * (utile si ton job tourne en Workload/Managed Identity mais doit se connecter
     * ensuite à un autre service avec un SPN stocké dans le Vault).
     */
    @Bean
    public SpnCredentialSupplier spnCredentialSupplier(VaultSecretService kv) {
        return new SpnCredentialSupplier(kv);
    }
}

// SpnCredentialSupplier.java
import com.azure.core.credential.TokenCredential;
import com.azure.identity.ClientSecretCredentialBuilder;

public class SpnCredentialSupplier {
    private final VaultSecretService kv;

    public SpnCredentialSupplier(VaultSecretService kv) { this.kv = kv; }

    public TokenCredential fromKeyVault(String tenantSecretName,
                                        String clientIdSecretName,
                                        String clientSecretName) {
        String tenant = kv.getSecret(tenantSecretName);
        String clientId = kv.getSecret(clientIdSecretName);
        String clientSecret = kv.getSecret(clientSecretName);
        return new ClientSecretCredentialBuilder()
                .tenantId(tenant).clientId(clientId).clientSecret(clientSecret).build();
    }
}


---

6) Exemple d’utilisation (dans ton job Spark)

// Création du contexte Spring (Core)
var ctx = new org.springframework.context.annotation.AnnotationConfigApplicationContext(AzureAuthConfig.class);

// Récupération des services
AzureTokenService tokens = ctx.getBean(AzureTokenService.class);
VaultSecretService vault = ctx.getBean(VaultSecretService.class);
SpnCredentialSupplier spnSupplier = ctx.getBean(SpnCredentialSupplier.class);

// 1) Obtenir un bearer ARM / KV / Storage selon besoin
String bearerKv = tokens.getBearer("https://vault.azure.net/.default");
String bearerArm = tokens.getBearer("https://management.azure.com/.default");
String bearerStg = tokens.getBearer("https://storage.azure.com/.default");

// 2) Lire un password dans Key Vault
String dbPassword = vault.getSecret("jdbc-password");

// 3) (Optionnel) Construire une cred SPN depuis secrets KV, puis l’utiliser
var spnCred = spnSupplier.fromKeyVault("spn-tenant-id", "spn-client-id", "spn-client-secret");
String bearerGraph = spnCred.getToken(
        new com.azure.core.credential.TokenRequestContext().addScopes("https://graph.microsoft.com/.default")
).block().getToken();


---

7) Points clés / bonnes pratiques

AKS Workload/Managed Identity : primaryCredential marchera sans secret, et les tokens sont mis en cache automatiquement par le SDK.

SPN dans Key Vault : lis les 3 secrets (tenant, clientId, clientSecret) via l’identité du pod, puis crée une ClientSecretCredential dédiée quand tu en as besoin.

Scopes utiles :

ARM : https://management.azure.com/.default

KV : https://vault.azure.net/.default

Storage : https://storage.azure.com/.default

SQL/Synapse : https://database.windows.net/.default

Graph : https://graph.microsoft.com/.default


Sécurité : ne loggue jamais clientSecret ni le bearer. Évite de “broadcast” un token Spark — crée la TokenCredential dans chaque process.



---

Si tu veux, je te fournis aussi un bean utilitaire SpringContextHolder pour appeler AzureTokenService depuis une méthode statique déjà existante sans toucher sa signature.
