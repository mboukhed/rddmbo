T’as raison — faisons ultra-simple :

1) Bean Spring qui fournit le TokenCredential

Choix auto : workload → managed → spn (via variables d’env) → default.

Zéro dépendance Spring Boot.


// AzureAuthConfig.java
import com.azure.core.credential.TokenCredential;
import com.azure.identity.*;
import org.springframework.context.annotation.*;

@Configuration
public class AzureAuthConfig {

    @Bean
    public TokenCredential azureCredential() {
        String mode = System.getProperty("azure.auth.mode",
                        System.getenv().getOrDefault("AZURE_AUTH_MODE", "auto")).toLowerCase();

        switch (mode) {
            case "workload":
                return new WorkloadIdentityCredentialBuilder().build();
            case "managed":
                return new ManagedIdentityCredentialBuilder().build();
            case "spn":
                String tenant  = getenvOrThrow("AZURE_TENANT_ID");
                String client  = getenvOrThrow("AZURE_CLIENT_ID");
                String secret  = getenvOrThrow("AZURE_CLIENT_SECRET");
                return new ClientSecretCredentialBuilder()
                        .tenantId(tenant).clientId(client).clientSecret(secret).build();
            default: // auto → laisse l’SDK détecter (Workload/Managed/Env, etc.)
                return new DefaultAzureCredentialBuilder().build();
        }
    }

    private static String getenvOrThrow(String k) {
        String v = System.getenv(k);
        if (v == null || v.isEmpty()) throw new IllegalStateException(k + " manquant");
        return v;
    }
}

2) Service minimal qui renvoie un token/bearer (SPN/MI/WI indifférent)

// SpnTokenService.java
import com.azure.core.credential.*;
import org.springframework.stereotype.Service;

@Service
public class SpnTokenService {
    private final TokenCredential cred;

    public SpnTokenService(TokenCredential cred) { this.cred = cred; }

    /** Ex: scope = "https://vault.azure.net/.default" */
    public AccessToken token(String scope) {
        return cred.getToken(new TokenRequestContext().addScopes(scope)).block();
    }

    public String bearer(String scope) {
        return token(scope).getToken();
    }
}

3) Utilisation

var ctx = new org.springframework.context.annotation.AnnotationConfigApplicationContext(AzureAuthConfig.class);
SpnTokenService tokens = ctx.getBean(SpnTokenService.class);

// Key Vault
String kvBearer = tokens.bearer("https://vault.azure.net/.default");
// ARM
String armBearer = tokens.bearer("https://management.azure.com/.default");
// Storage
String stgBearer = tokens.bearer("https://storage.azure.com/.default");

4) Comment piloter le mode (sans changer le code)

Workload Identity : -Dazure.auth.mode=workload (ou AZURE_AUTH_MODE=workload)

Managed Identity : -Dazure.auth.mode=managed

SPN : -Dazure.auth.mode=spn + variables d’env :

AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET


Auto (défaut) : rien à faire.


5) Scopes utiles (rappel)

ARM : https://management.azure.com/.default

Key Vault : https://vault.azure.net/.default

Storage : https://storage.azure.com/.default

SQL/Synapse : https://database.windows.net/.default

Graph : https://graph.microsoft.com/.default


C’est tout. Deux classes, pas de blabla, ça marche dans AKS (Workload/Managed) et en local (SPN).
