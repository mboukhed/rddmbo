Excellent r√©flexe üëå ‚Äî c‚Äôest exactement le cas classique o√π Spring et le code statique se croisent.
‚û°Ô∏è Une m√©thode statique ne peut pas recevoir d‚Äôinjection Spring directe (@Autowired impossible).
Mais il existe 3 solutions propres selon ton architecture et ton niveau de contr√¥le sur la classe.


---

üß© 1Ô∏è‚É£ ‚Äî Utiliser un ‚ÄúSpringContextHolder‚Äù (propre et universel)

Tu cr√©es un bean utilitaire qui garde une r√©f√©rence statique au contexte Spring :

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class SpringContextHolder implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext ctx) throws BeansException {
        context = ctx;
    }

    public static <T> T getBean(Class<T> clazz) {
        return context.getBean(clazz);
    }

    public static Object getBean(String name) {
        return context.getBean(name);
    }
}

‚úÖ Une fois ce bean initialis√© au d√©marrage, tu peux r√©cup√©rer n‚Äôimporte quel bean Spring depuis une m√©thode statique :

public class ParquetWriterUtil {

    public static void writeAndExport(Dataset<Row> df, String path) {
        df.write().parquet(path);

        // R√©cup√©ration d‚Äôun bean Spring dans une m√©thode statique
        ClickHouseExporter exporter = SpringContextHolder.getBean(ClickHouseExporter.class);
        exporter.export(df);
    }
}

üí° Avantage :

Pas besoin de casser ton code.

R√©cup√©ration propre, contr√¥l√©e et thread-safe.

Compatible m√™me avec tes tests Cucumber/SpringCore non-boot.



---

üß© 2Ô∏è‚É£ ‚Äî Injection indirecte via Singleton non statique

Si tu peux l√©g√®rement refactoriser la classe :

@Component
public class ParquetWriterService {
    private final ClickHouseExporter exporter;

    @Autowired
    public ParquetWriterService(ClickHouseExporter exporter) {
        this.exporter = exporter;
    }

    public static ParquetWriterService instance;

    @PostConstruct
    public void init() {
        instance = this;
    }

    public static void writeAndExport(Dataset<Row> df, String path) {
        df.write().parquet(path);
        instance.exporter.export(df);
    }
}

‚úÖ Les anciens appels ParquetWriterService.writeAndExport(...) restent valides,
mais tu b√©n√©ficies d‚Äôun acc√®s Spring propre.


---

üß© 3Ô∏è‚É£ ‚Äî Passer le bean via param√®tre d‚Äôenvironnement (si vraiment statique ‚Äúpur‚Äù)

Si ton code statique est charg√© avant le contexte Spring (ex. dans un Spark job ‚Äúpur‚Äù),
tu peux passer le bean via une factory statique au d√©marrage :

ParquetWriterUtil.init(clickHouseExporter);
ParquetWriterUtil.write(df, path);

avec :

public class ParquetWriterUtil {
    private static ClickHouseExporter exporter;

    public static void init(ClickHouseExporter exp) {
        exporter = exp;
    }
}

üí° Pratique pour tes tests unitaires Spark hors Spring, mais plus manuel.


---

‚úÖ En r√©sum√©

Besoin	Solution	Impact

Acc√©der √† un bean Spring depuis une m√©thode statique	SpringContextHolder ‚úÖ	aucune modif majeure
Tu veux rester ‚ÄúSpring-pur‚Äù	@PostConstruct + instance statique	tr√®s propre
Pas de Spring (ex√©cution Spark standalone)	init(exporter) manuel	simple, hors contexte



---

üëâ Recommandation claire pour ton cas :

> Cr√©e un petit SpringContextHolder (solution 1).
Tu gardes ta m√©thode statique intacte et tu r√©cup√®res proprement le bean dont tu as besoin (ClickHouseExporter, VaultClient, etc.).



Souhaites-tu que je t‚Äô√©crive une version exactement adapt√©e √† ton projet Spark Core non-Boot (sans d√©pendance Spring Boot, juste ApplicationContext standard) ?
